# goit-algo-hw-09
## Жадібний алгоритм
- Часова складність: О(n), де n - кількість номіналів монет. Жадібний алгоритм перевіряє кожен номінал монети один раз для визначення кількості монет, що використовуються, що робить його досить швидким для обчислень.
- Просторова складність: О(1), не враховуючи вихідні дані, оскільки алгоритм зберігає обмежену кількість змінних незалежно від розміру вхідних даних.
- Точність: Може не завжди знаходити мінімальну кількість монет для решти через його жадібний підхід, особливо при особливо складених наборах монет.
## Алгоритм динамічного програмування
- Часова складність: О(mn), де m - сума, для якої потрібно знайти решту, а n - кількість номіналів монет. Алгоритм розглядає кожен номінал для кожної суми від 1 до m, що може стати досить витратним при великих сумах.
- Просторова складність: О(m), оскільки необхідно зберігати масив з мінімальною кількістю монет для кожної суми від 1 до m.
- Точність: Завжди знаходить мінімальну кількість монет для будь-якої суми, що робить його точним, але потенційно більш витратним за часом.
## Висновки
- Жадібний алгоритм ефективний при роботі з системами монет, де жадібний підхід завжди веде до оптимального рішення (наприклад, при використанні стандартних номіналів монет). Він швидкий і вимагає мало пам'яті, що робить його ідеальним для великих сум, якщо набір монет дозволяє жадібний алгоритм досягати оптимального результату.
- Алгоритм динамічного програмування гарантує знаходження мінімальної кількості монет для будь-якої суми та будь-якого набору номіналів монет. Це робить його надзвичайно надійним у ситуаціях, де жадібний алгоритм може не забезпечити оптимальне рішення. Однак, ця точність має свою ціну у вигляді вищої часової та просторової складності, особливо при роботі з великими сумами.
## Коли використовувати кожен алгоритм
- Жадібний алгоритм є відмінним вибором, коли відомо, що набір монет дозволяє жадібному підходу завжди досягати оптимального рішення. Він швидкий і ефективний для реалізації, особливо в системах, де час виконання та економія пам'яті є критично важливими.
- Алгоритм динамічного програмування ідеально підходить для складних систем номіналів монет, де жадібний алгоритм може не забезпечити оптимального рішення. Він також корисний, коли потрібно гарантувати отримання мінімальної кількості монет незалежно від суми. Цей підхід краще всього використовувати, коли точність є пріоритетом над швидкістю виконання та використанням пам'яті.
## Узагальнення
Обидва алгоритми мають своє місце в залежності від контексту задачі. Для практичних застосувань, де потрібно швидко вираховувати решту, жадібний алгоритм може бути більш вигідним, особливо якщо набір монет добре адаптований для його використання. Алгоритм динамічного програмування краще використовувати в академічних або теоретичних обчисленнях, де важливо знайти абсолютно точне рішення без компромісів.

+--------+-----------------------+--------------------------------------+--------------------------+------------------------------------+--------------------------------------+---------------------------+
| Amount | Greedy Algorithm Time |       Greedy Algorithm Result        | Amount of coins (greedy) | Dynamic Programming Algorithm Time | Dynamic Programming Algorithm Result | Amount of coins (dynamic) |
+--------+-----------------------+--------------------------------------+--------------------------+------------------------------------+--------------------------------------+---------------------------+
|   57   |        0.000109       |         {50: 1, 5: 1, 2: 1}          |            3             |              0.00596               |         {2: 1, 5: 1, 50: 1}          |             3             |
|  1013  |        0.000151       |     {50: 20, 10: 1, 2: 1, 1: 1}      |            23            |              0.139291              |     {1: 1, 2: 1, 10: 1, 50: 20}      |             23            |
|  9995  |        0.000115       |       {50: 199, 25: 1, 10: 2}        |           202            |              1.617203              |       {10: 2, 25: 1, 50: 199}        |            202            |
| 54544  |        0.000136       | {50: 1090, 25: 1, 10: 1, 5: 1, 2: 2} |           1095           |              9.002713              | {2: 2, 5: 1, 10: 1, 25: 1, 50: 1090} |            1095           |
| 100142 |        0.000263       | {50: 2002, 25: 1, 10: 1, 5: 1, 2: 1} |           2006           |             17.207103              | {2: 1, 5: 1, 10: 1, 25: 1, 50: 2002} |            2006           |
+--------+-----------------------+--------------------------------------+--------------------------+------------------------------------+--------------------------------------+---------------------------+
